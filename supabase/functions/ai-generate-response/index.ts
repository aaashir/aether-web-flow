
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type"
};

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { message, messageId } = await req.json();

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get("SUPABASE_URL") || "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") || "";
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // Get OpenAI API key
    const openAIKey = Deno.env.get("OPENAI_API_KEY");
    if (!openAIKey) {
      throw new Error("OpenAI API key not found");
    }

    // Process message and determine if it's requesting a block
    const isBlockRequest = detectBlockRequest(message);
    
    // Call OpenAI API for response
    const openaiResponse = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${openAIKey}`
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        messages: [
          {
            role: "system",
            content: isBlockRequest 
              ? "You are an AI assistant that helps users create website blocks. Generate JSON for the requested block type." 
              : "You are an AI assistant that helps users build websites. Keep responses helpful and concise."
          },
          { role: "user", content: message }
        ],
        temperature: 0.7,
        max_tokens: isBlockRequest ? 2000 : 500
      })
    });

    if (!openaiResponse.ok) {
      const errorData = await openaiResponse.json();
      console.error("OpenAI API error:", errorData);
      throw new Error("Failed to get AI response");
    }

    const openaiData = await openaiResponse.json();
    const aiResponse = openaiData.choices[0].message.content;

    let blockId = null;
    
    // If this is a block request, create the block
    if (isBlockRequest) {
      try {
        // Extract the block configuration from the AI response
        const blockConfig = extractBlockConfig(aiResponse);
        
        // Get user_id from the message
        const { data: messageData } = await supabase
          .from('chat_messages')
          .select('user_id')
          .eq('id', messageId)
          .single();
          
        if (!messageData) {
          throw new Error("Message not found");
        }
        
        // Create the block
        const { data: blockData, error: blockError } = await supabase
          .from('custom_blocks')
          .insert({
            user_id: messageData.user_id,
            name: blockConfig.name || 'AI Generated Block',
            preview: blockConfig.preview || 'Custom block generated by AI',
            content: blockConfig.content,
            styles: blockConfig.styles,
            category: 'custom'
          })
          .select()
          .single();
          
        if (blockError) {
          throw blockError;
        }
        
        blockId = blockData.id;
      } catch (error) {
        console.error("Error creating block:", error);
        // Still return a response even if block creation failed
      }
    }
    
    // Return the AI response and block creation status
    return new Response(
      JSON.stringify({
        response: aiResponse,
        isGeneratingBlock: isBlockRequest && blockId !== null,
        blockId
      }),
      { 
        headers: { 
          ...corsHeaders, 
          "Content-Type": "application/json" 
        }
      }
    );
    
  } catch (error) {
    console.error("Error:", error.message);
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        status: 500, 
        headers: { 
          ...corsHeaders, 
          "Content-Type": "application/json" 
        }
      }
    );
  }
});

// Helper function to detect if a message is requesting a block
function detectBlockRequest(message: string): boolean {
  const blockKeywords = [
    'create a block', 'make a block', 'generate a block',
    'design a section', 'build a component', 'add a section',
    'create a component', 'make a section', 'design a block'
  ];
  
  const lowerMessage = message.toLowerCase();
  return blockKeywords.some(keyword => lowerMessage.includes(keyword));
}

// Helper function to extract block configuration from AI response
function extractBlockConfig(response: string) {
  try {
    // Try to extract JSON from response
    const jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/) || 
                      response.match(/{[\s\S]*}/);
                      
    if (jsonMatch) {
      const jsonString = jsonMatch[0].replace(/```json|```/g, '');
      const blockConfig = JSON.parse(jsonString);
      
      // Ensure the block has the required properties
      return {
        name: blockConfig.name || 'AI Generated Block',
        preview: blockConfig.preview || 'Custom block created by AI',
        content: blockConfig.content || {},
        styles: blockConfig.styles || {}
      };
    }
    
    // Fallback if no JSON found
    return {
      name: 'AI Generated Block',
      preview: 'Custom block created by AI',
      content: { text: response },
      styles: { padding: '20px', backgroundColor: '#ffffff' }
    };
  } catch (error) {
    console.error("Error extracting block config:", error);
    // Return default block configuration
    return {
      name: 'AI Generated Block',
      preview: 'Custom block created by AI',
      content: { text: response },
      styles: { padding: '20px', backgroundColor: '#ffffff' }
    };
  }
}
